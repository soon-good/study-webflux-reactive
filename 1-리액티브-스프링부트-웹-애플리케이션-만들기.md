# 1. 리액티브 스프링부트 웹 애플리케이션 만들기

공부하는 나의 입장에서도 리액티브 스프링부트의 장점을 잘 모른다. 처음부터 다 알고 있으면 공부할 필요가 없겠지. DB에서 한번에 데이터를 가져오지 않고 조금씩 단위를 설정해서 가져오는 경우가 있는데, 이것을 이벤트 스트림 기반으로 개선할 수 있는 경우 역시 있지 않을까 싶었다. <br>

<br>

최신 트렌드의 웹 애플리케이션들은 일단은 캐시에 데이터를 올려두고, 이 캐시의 유효기간동안 데이터를 보관한다. 레디스에 데이터를 보관할 때 데이터를 조회할 때에도 비동기적으로 수행한다면, 성능상의 이점을 도모할 수 있지 않을까 하는 생각도 들었다. 오늘 쓴 소감은 또 정리가 필요할 듯하다...<br>

<br>

## 참고자료

- [스프링 부트 실전 활용 마스터 - 그렉 턴키스트](http://www.yes24.com/Product/Goods/101803558)

<br>

## 리액티브 프로그래밍이란

리액티브 프로그래밍은 1970년 대에 관련된 학술자료가 처음 나왔다. 또한 리액티브 프로그래밍에 사용될 수 있는 비동기, 이벤트 주도 프로그래밍 기술 역시 나온지 어느 정도 시간이 흘렀다. 아직은 리액티브 프로그래밍이 주류 프로그래밍 방식은 아니다. 책을 찬찬히 읽어보다 보니 리액티브 프로그래밍은 헌번에 모든 결과를 `List<Book> books` 와 같은 형태로 가져오지 않는다. `Flux<Book> books` 와 같은 방식으로 가져온다. 그리고 `List<Book> books` 와 `Flux<Book> books` 의 차이점을 정리해보면 아래와 같다.<br>

- `List<Book> books` 
  - 한번에 모든 리스트를 가져온다. 
  - 과거에서부터 현재시대까지의 프로그래밍 트렌드였다.
  - 한번에 가져와야 하는 데이터의 양이 많아서 부하가 걸릴때가 있다.
  - 이런 이유로 페이지네이션 기법들이 많고, limit, offset 등을 적용해서 사용하는 경우가 꽤 많다.
  - 기획 적인 측면에서 제품의 성능과 안정성을 고려하는 경우가 많았다. 이런 점은 확실히 멋있다는 생각이 든다.
- `Flux<Book> books` 
  - 리액티브 방식에서 List 와 같이 여러개의 타입들을 선형적으로 가지고 있을 때 사용한다.
  - 단일 데이터는 Mono 에 담아두는 듯 하다. (예전 모던 자바 인 액션 책을 읽을때 알게되었던 내용)
  - 데이터를 받는 데로 클라이언트에 전달해주는 방식이다.
  - 한번에 모아서 클라이언트에게 전달해주지 않는다. 데이터가 오면 오는데로 몇개씩 전달해줄지 단위를 지정해서 전달해준다.
  - 웹에서 사용할 경우 클라이언트가 `text/event-stream`을 실어서 요청을 하게 되는데, 이렇게 하면 webflux 를 지원하는 서버 애플리케이션의 경우 리액티브 방식의 데이터 전송방식으로 데이터를 전달해줄 수 있게 된다.

<br>

**리액티브 스트림**<br>

이렇게 데이터가 몇개 단위로 모이면 클라이언트에게 전달해주고 하는 이런 방식을 `리액티브 스트림(Reactive Stream)` 이라고 한다. [리액티브 스트림](http://www.reactive-streams.org/) 은 **발행자(Publisher)**와 **구독자(Subscriber)**사이의 **간단한 계약을 정의하는 명세**이다.<br>

<br>

**demand control (수요 조절)**<br>

- 구독자
  - '어이, 발행자님, 난 10개만 더 받을수 있어.'
- 발행자
  - '알았어 10개만 더 보낼께'

<br>

**backpressure (배압)**<br>

- 시스템을 발행자 - 구독자 관계로 연결할 경우 시스템 범위의 backpressure 를 적용할 수 있다.
- 성능이 획기적으로 개선되는 것은 아니지만 트래픽을 잘 조절해서 관리할 수 있는 장점이 있다.

<br>





## 정리 필요쓰... 천천히 정리할 예정...


집에가서 더 정리해야 겠지만, 기억나는 것만 빠르게 떠올려서 메모해보면 이렇다.<br>

스프링 웹 플럭스 기반의 컨테이너는 임베디드 톰캣이 아니라 네티 컨테이너를 사용한다.<br>

요청 헤더는 `text/event-stream` 이다. 특이하다.<br>

```java
class PoliteServer{
  private final KitchenService kitchen;
  
  PoliteServer(KitchenService kitchen){
    this.kitchen = kitchen;
  }
  
  Flux<Dish> doingMyJob(){
    return this.kitchen.getDishes()
      .doOnNext(dish -> System.out.println("주문하신 " + dish.getName() + " 가 나왔습니다."))
      .doOnError(error -> System.out.println("[에러] " + error.getMessage()))
      .doOnComplete(()-> System.out.println("감사합니다."))
      .map(Dish::deliver);
  }
  
  public static void main(String [] args){
    PoliteServer server = new PoliteServer(new KitchenService());
    
    server.doingMyJob().subscribe(
      dish -> System.out.println("Consuming " + dish);
      throwable -> System.err.println(throwable);
    );
  }
}
```

subscribe() 를 호출하지 않으면 doingMyJob() 을 호출하더라도 아무 일도 일어나지 않는다. 리액터 애플리케이션에서는 구독하기 전 까지는 아무일도 일어나지 않는다. main() 메서드 안에서 subscribe() 가 호출되어야 그 때부터 뭔가가 동작하기 시작한다.<br>

**Future 인터페이스와 Flux의 차이점**<br>

이 부분에서 조금 오? 하는 생각이 들었다. 일단은 집에서 더 정리할 생각으로 받아 적어놓는다.

- 하나 이상의 Dish(요리) 포함 가능
- 각 Dish(요리)가 제공될 때 어떤 일이 발생하는지 지정 가능
- 성공과 실패의 두 가지 경로 모두에 대한 처리 방향 정의 가능
- 결과 폴링 (polling) 불필요
- 함수형 프로그래밍 지원

<br>

나머지는 집에서... 의외로 웹 플럭스 말고도 spring, maven plugin 등에 대해 유용한 것들을 차분하게 설명해주고 있어서 정리할 만한 가치가 있는 책이라는 생각이 많이 들었다.

<br>